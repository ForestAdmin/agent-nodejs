import {
  AbstractDataType,
  Association,
  BelongsTo,
  BelongsToMany,
  HasMany,
  HasOne,
  Model,
  ModelAttributeColumnOptions,
  ModelAttributes,
  ModelDefined,
} from 'sequelize';

import {
  CollectionSchema,
  ColumnSchema,
  FieldSchema,
  Logger,
  RelationSchema,
} from '@forestadmin/datasource-toolkit';

import SequelizeModelAttributes from './sequelize-model-attributes';
import TypeConverter from './type-converter';

export default class ModelToCollectionSchemaConverter {
  private static convertAssociation(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    association: Association<Model<any, any>, Model<any, any>>,
  ): RelationSchema {
    switch (association.associationType) {
      case BelongsTo.name:
        return {
          foreignCollection: association.target.name,
          foreignKey: association.foreignKey,
          foreignKeyTarget: (association as unknown as { targetKey: string }).targetKey,
          type: 'ManyToOne',
        };
      case BelongsToMany.name:
        return {
          foreignCollection: association.target.name,
          throughCollection: (association as BelongsToMany).through.model.name,
          originKey: (association as BelongsToMany).foreignKey,
          originKeyTarget: (association as BelongsToMany).targetKey,
          foreignKey: (association as BelongsToMany).otherKey,
          foreignKeyTarget: (association as BelongsToMany).sourceKey,
          type: 'ManyToMany',
        };
      case HasMany.name:
        return {
          foreignCollection: association.target.name,
          originKey: association.foreignKey,
          originKeyTarget: (association as unknown as { sourceKey: string }).sourceKey,
          type: 'OneToMany',
        };
      case HasOne.name:
        return {
          foreignCollection: association.target.name,
          originKey: association.foreignKey,
          originKeyTarget: (association as unknown as { sourceKey: string }).sourceKey,
          type: 'OneToOne',
        };
      default:
        throw new Error(`Unsupported association: "${association.associationType}".`);
    }
  }

  private static convertAssociations(
    modelName: string,
    associations: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      [key: string]: Association<Model<any, any>, Model<any, any>>;
    },
    logger: Logger,
  ): CollectionSchema['fields'] {
    const schemaAssociations = {};

    if (associations) {
      Object.entries(associations).forEach(([name, association]) => {
        try {
          schemaAssociations[name] = this.convertAssociation(association);
        } catch (error) {
          logger?.('Warn', `Skipping association '${modelName}.${name}' (${error.message})`);
        }
      });
    }

    return schemaAssociations;
  }

  private static convertAttribute(attribute: ModelAttributeColumnOptions): FieldSchema {
    const sequelizeColumnType = attribute.type as AbstractDataType;
    const columnType = TypeConverter.fromDataType(sequelizeColumnType);
    const filterOperators = TypeConverter.operatorsForColumnType(columnType);
    const column: ColumnSchema = {
      columnType,
      filterOperators,
      type: 'Column',
      validation: [],
      isReadOnly: attribute.autoIncrement,
      isSortable: true,
    };

    if (
      attribute.allowNull === false &&
      !column.isReadOnly &&
      !attribute.defaultValue &&
      // eslint-disable-next-line no-underscore-dangle
      !attribute._autoGenerated
    ) {
      column.validation.push({ operator: 'Present' });
    }

    if (attribute.primaryKey) column.isPrimaryKey = true;

    if (
      attribute.defaultValue !== null &&
      attribute.defaultValue !== undefined &&
      (columnType === 'Json' || typeof attribute.defaultValue !== 'object')
    ) {
      column.defaultValue = attribute.defaultValue;
    }

    if (attribute.values) {
      column.enumValues = [...attribute.values];
    }

    return column;
  }

  private static convertAttributes(
    modelName: string,
    attributes: ModelAttributes,
    logger: Logger,
  ): CollectionSchema['fields'] {
    const fields: CollectionSchema['fields'] = {};

    Object.entries(attributes).forEach(([name, attribute]) => {
      try {
        fields[name] = this.convertAttribute(attribute as ModelAttributeColumnOptions);
      } catch (error) {
        logger?.('Warn', `Skipping column '${modelName}.${name}' (${error.message})`);
      }
    });

    return fields;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public static convert(model: ModelDefined<any, any>, logger: Logger): CollectionSchema {
    if (!model) throw new Error('Invalid (null) model.');

    return {
      actions: {},
      countable: true,
      fields: {
        ...this.convertAttributes(
          model.name,
          SequelizeModelAttributes.getAttributes(model),
          logger,
        ),
        ...this.convertAssociations(model.name, model.associations, logger),
      },
      searchable: false,
      segments: [],
    };
  }
}
