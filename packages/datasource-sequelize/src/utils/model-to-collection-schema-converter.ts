import {
  CollectionSchema,
  ColumnSchema,
  ColumnType,
  FieldSchema,
  Logger,
  RelationSchema,
} from '@forestadmin/datasource-toolkit';
import {
  AbstractDataType,
  Association,
  BelongsTo,
  BelongsToMany,
  DataTypes,
  HasMany,
  HasOne,
  Model,
  ModelAttributeColumnOptions,
  ModelAttributes,
  ModelDefined,
} from 'sequelize';

import TypeConverter from './type-converter';

type Options = { castUuidToString: boolean };

export default class ModelToCollectionSchemaConverter {
  private static convertAssociation(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    association: Association<Model<any, any>, Model<any, any>>,
  ): RelationSchema {
    switch (association.associationType) {
      case BelongsTo.name:
        return {
          foreignCollection: association.target.name,
          foreignKey: association.foreignKey,
          foreignKeyTarget: (association as unknown as { targetKey: string }).targetKey,
          type: 'ManyToOne',
        };
      case BelongsToMany.name:
        return {
          foreignCollection: association.target.name,
          throughCollection: (association as BelongsToMany).through.model.name,
          originKey: (association as BelongsToMany).foreignKey,
          originKeyTarget: (association as BelongsToMany).sourceKey,
          foreignKey: (association as BelongsToMany).otherKey,
          foreignKeyTarget: (association as BelongsToMany).targetKey,
          type: 'ManyToMany',
        };
      case HasMany.name:
        return {
          foreignCollection: association.target.name,
          originKey: association.foreignKey,
          originKeyTarget: (association as unknown as { sourceKey: string }).sourceKey,
          type: 'OneToMany',
        };
      case HasOne.name:
        return {
          foreignCollection: association.target.name,
          originKey: association.foreignKey,
          originKeyTarget: (association as unknown as { sourceKey: string }).sourceKey,
          type: 'OneToOne',
        };
      default:
        throw new Error(`Unsupported association: "${association.associationType}".`);
    }
  }

  private static convertAssociations(
    modelName: string,
    associations: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      [key: string]: Association<Model<any, any>, Model<any, any>>;
    },
    logger: Logger,
  ): CollectionSchema['fields'] {
    const schemaAssociations = {};

    if (associations) {
      Object.entries(associations).forEach(([name, association]) => {
        try {
          schemaAssociations[name] = this.convertAssociation(association);
        } catch (error) {
          logger?.('Warn', `Skipping association '${modelName}.${name}' (${error.message})`);
        }
      });
    }

    return schemaAssociations;
  }

  private static convertAttribute(
    attribute: ModelAttributeColumnOptions,
    options?: Options,
  ): FieldSchema {
    const sequelizeColumnType = attribute.type as AbstractDataType;
    const columnType = TypeConverter.fromDataType(sequelizeColumnType);
    const filterOperators = TypeConverter.operatorsForColumnType(columnType);
    const column: ColumnSchema = {
      columnType,
      filterOperators,
      type: 'Column',
      validation: [],
      isReadOnly: attribute.autoIncrement,
      isSortable: true,
    };

    if (
      attribute.allowNull === false &&
      !column.isReadOnly &&
      !attribute.defaultValue &&
      // eslint-disable-next-line no-underscore-dangle
      !attribute._autoGenerated
    ) {
      column.validation.push({ operator: 'Present' });
    }

    if (attribute.primaryKey) column.isPrimaryKey = true;

    if (
      attribute.defaultValue !== null &&
      attribute.defaultValue !== undefined &&
      (columnType === 'Json' || typeof attribute.defaultValue !== 'object')
    ) {
      column.defaultValue = attribute.defaultValue;
    }

    this.convertEnumAttribute(columnType, column, attribute);
    if (options?.castUuidToString) this.convertUuidAttribute(columnType, column);

    return column;
  }

  private static convertEnumAttribute(
    columnType: ColumnType,
    column: ColumnSchema,
    attribute: ModelAttributeColumnOptions<Model>,
  ) {
    if (columnType === 'Enum') {
      column.enumValues = [...attribute.values];
    } else if (ModelToCollectionSchemaConverter.isArrayOf(columnType, 'Enum')) {
      const arrayType = attribute.type as DataTypes.ArrayDataType<DataTypes.EnumDataType<string>>;
      column.enumValues = [...arrayType.options.type.values];
    }
  }

  private static convertUuidAttribute(columnType: ColumnType, column: ColumnSchema) {
    if (columnType === 'Uuid') {
      column.columnType = 'String';
      column.filterOperators = TypeConverter.operatorsForColumnType('String');
    } else if (ModelToCollectionSchemaConverter.isArrayOf(columnType, 'Uuid')) {
      column.columnType = ['String'];
      column.filterOperators = TypeConverter.operatorsForColumnType(['String']);
    }
  }

  private static isArrayOf(columnType: ColumnType, type: ColumnType): boolean {
    return Array.isArray(columnType) && columnType[0] === type;
  }

  private static convertAttributes(
    modelName: string,
    attributes: ModelAttributes,
    logger: Logger,
    options?: Options,
  ): CollectionSchema['fields'] {
    const fields: CollectionSchema['fields'] = {};

    Object.entries(attributes).forEach(([name, attribute]) => {
      try {
        fields[name] = this.convertAttribute(attribute as ModelAttributeColumnOptions, options);
      } catch (error) {
        logger?.('Warn', `Skipping column '${modelName}.${name}' (${error.message})`);
      }
    });

    return fields;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public static convert(
    model: ModelDefined<any, any>,
    logger: Logger,
    options?: Options,
  ): CollectionSchema {
    if (!model) throw new Error('Invalid (null) model.');

    return {
      actions: {},
      charts: [],
      countable: true,
      fields: {
        ...this.convertAttributes(model.name, model.getAttributes(), logger, options),
        ...this.convertAssociations(model.name, model.associations, logger),
      },
      searchable: false,
      segments: [],
    };
  }
}
