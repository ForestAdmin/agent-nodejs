import { ColumnsDescription, Dialect, ModelAttributes, Sequelize } from 'sequelize';
import { DataSource, Logger } from '@forestadmin/datasource-toolkit';
import { SequelizeDataSource } from '@forestadmin/datasource-sequelize';

import { Builder, FieldDescription, ForeignKeyReference, Model } from './utils/types';
import DefaultValueParser from './utils/default-value-parser';
import SqlTypeConverter from './utils/sql-type-converter';

export default class SequelizeDataSourceBuilder extends SequelizeDataSource implements Builder {
  logger?: Logger;

  constructor(connectionUri: string, logger?: Logger) {
    const logging = (sql: string) => logger?.('Debug', sql.substring(sql.indexOf(':') + 2));
    super(new Sequelize(connectionUri, { logging }));
    this.logger = logger;
  }

  buildDataSource(): DataSource {
    super.createCollections(this.sequelize.models, this.logger);

    return this;
  }

  get models(): { [modelName: string]: Model } {
    return Object.keys(this.sequelize.models).reduce((models, modelName) => {
      const model = this.sequelize.model(modelName);

      models[modelName] = {
        getAttributes: () => model.getAttributes(),
        name: modelName,
        associations: model.associations,
      };

      return models;
    }, {});
  }

  async defineModel(tableName): Promise<void> {
    const columnDescriptions = await this.sequelize.getQueryInterface().describeTable(tableName);
    const fieldDescriptions = await this.buildFieldDescriptions(columnDescriptions, tableName);
    this.buildModel(tableName, fieldDescriptions);
  }

  async defineRelation(tableName: string): Promise<void> {
    const foreignReferences = await this.getForeignReferences(tableName);

    if (this.isJunctionTable(tableName)) {
      this.buildForJunctionTable(
        tableName,
        foreignReferences as [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
      );
    } else {
      const uniqueFields = await this.getUniqueFields(tableName);
      this.buildOtherRelations(foreignReferences, tableName, uniqueFields);
    }
  }

  async getRelatedTables(tableName: string): Promise<string[]> {
    const foreignReferences = await this.getForeignReferences(tableName);

    if (this.isJunctionTable(tableName)) {
      const [{ referencedTableName: tableA }, { referencedTableName: tableB }] = foreignReferences;

      return [tableA, tableB];
    }

    return foreignReferences.map(({ referencedTableName }) => referencedTableName);
  }

  /**
   * Fixes Sequelize behavior incorrectly implemented.
   * Types indicate that showAllTables() should return a list of string, but it
   * returns a list of object for both mariadb & mssql
   * @see https://github.com/sequelize/sequelize/blob/main/src/dialects/mariadb/query.js#L295
   */
  async getTableNames(): Promise<string[]> {
    const names: ({ tableName: string } | string)[] = await this.sequelize
      .getQueryInterface()
      .showAllTables();

    return names.map(name => (typeof name === 'string' ? name : name?.tableName));
  }

  private async getForeignReferences(tableName: string): Promise<ForeignKeyReference[]> {
    return this.sequelize.getQueryInterface().getForeignKeyReferencesForTable(tableName);
  }

  private async getUniqueFields(tableName: string): Promise<string[]> {
    const tableIndex = await this.sequelize.getQueryInterface().showIndex(tableName);

    return tableIndex
      .filter(({ primary, unique, fields }) => !primary && unique && fields.length === 1)
      .map(({ fields }) => fields.map(({ attribute }) => attribute))
      .flat();
  }

  private async buildFieldDescriptions(
    columnDescriptions: ColumnsDescription,
    tableName: string,
  ): Promise<FieldDescription[]> {
    const fields = Object.entries(columnDescriptions).map(
      async ([columnName, columnDescription]) => {
        try {
          const type = await new SqlTypeConverter(this.sequelize).convert(
            tableName,
            columnName,
            columnDescription,
          );

          let defaultValue = new DefaultValueParser(this.sequelize.getDialect() as Dialect).parse(
            columnDescription.defaultValue,
            type,
          );

          if (columnDescription.primaryKey && defaultValue) {
            defaultValue = null;
            columnDescription.autoIncrement = true;
          }

          return [columnName, { ...columnDescription, type, defaultValue }];
        } catch (e) {
          this.logger?.('Warn', `Skipping column ${tableName}.${columnName} (${e.message})`);
        }
      },
    );

    const fieldDescriptions = await Promise.all(fields);

    return fieldDescriptions.filter(Boolean);
  }

  private isJunctionTable(modelName: string): boolean {
    const model = this.sequelize.model(modelName);
    const modelAttributes = model.getAttributes();
    // remove autogenerated field to keep the belongsToMany behavior
    const attributes = Object.values(modelAttributes);
    const modelAttributesDefinition = attributes.filter(({ _autoGenerated }) => !_autoGenerated);
    if (modelAttributesDefinition.length !== 2) return false;

    return !modelAttributesDefinition.some(({ primaryKey }) => !primaryKey);
  }

  private buildForJunctionTable(
    modelName: string,
    foreignReferences: [Partial<ForeignKeyReference>, Partial<ForeignKeyReference>],
  ): void {
    const [
      { referencedTableName: tableA, columnName: columnA, referencedColumnName: referencedColumnA },
      { referencedTableName: tableB, columnName: columnB, referencedColumnName: referencedColumnB },
    ] = foreignReferences;

    const model = this.sequelize.model(modelName);
    const modelA = this.sequelize.model(tableA);
    const modelB = this.sequelize.model(tableB);
    const through = model.name;

    modelA.belongsToMany(modelB, { through, foreignKey: columnA, otherKey: columnB });
    modelB.belongsToMany(modelA, { through, foreignKey: columnB, otherKey: columnA });
    model.belongsTo(modelA, { foreignKey: columnA, targetKey: referencedColumnA });
    model.belongsTo(modelB, { foreignKey: columnB, targetKey: referencedColumnB });
  }

  private buildOtherRelations(
    foreignReferences: Partial<ForeignKeyReference>[],
    modelName: string,
    uniqueFields: string[],
  ): void {
    foreignReferences.forEach(
      ({ columnName: foreignKey, referencedTableName, referencedColumnName: sourceKey }) => {
        const referencedModel = this.sequelize.model(referencedTableName);

        const model = this.sequelize.model(modelName);
        model.belongsTo(referencedModel, { foreignKey, targetKey: sourceKey });

        if (uniqueFields.includes(foreignKey)) {
          referencedModel.hasOne(model, { foreignKey, sourceKey });
        } else {
          referencedModel.hasMany(model, { foreignKey, sourceKey });
        }
      },
    );
  }

  private buildModel(tableName: string, fieldDescriptions: FieldDescription[]): void {
    let model: ModelAttributes = Object.fromEntries(fieldDescriptions);

    const columnNames = Object.keys(model);
    const timestamps = SequelizeDataSourceBuilder.hasTimestamps(columnNames);
    const paranoid = SequelizeDataSourceBuilder.isParanoid(columnNames);

    if (timestamps) {
      model = SequelizeDataSourceBuilder.removeTimestampColumns(model);
    }

    if (paranoid) {
      model = SequelizeDataSourceBuilder.removeParanoidColumn(model);
    }

    this.sequelize.define(tableName, model, { tableName, timestamps, paranoid });
  }

  private static removeTimestampColumns(modelDefinition: ModelAttributes): ModelAttributes {
    const copy = { ...modelDefinition };
    delete copy.createdAt;
    delete copy.updatedAt;

    return copy;
  }

  private static isParanoid(columnNames: string[]): boolean {
    return columnNames.includes('deletedAt');
  }

  private static removeParanoidColumn(modelDefinition: ModelAttributes): ModelAttributes {
    const copy = { ...modelDefinition };
    delete copy.deletedAt;

    return copy;
  }

  private static hasTimestamps(columnNames: string[]): boolean {
    const hasCreatedAt = columnNames.includes('createdAt');
    const hasUpdatedAt = columnNames.includes('updatedAt');

    return hasCreatedAt && hasUpdatedAt;
  }
}
