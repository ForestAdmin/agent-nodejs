import type { ColumnDescription } from './dialects/dialect.interface';
import type IntrospectionDialect from './dialects/dialect.interface';
import type {
  QueryInterfaceExt,
  SequelizeReference,
  SequelizeTableIdentifier,
  SequelizeWithOptions,
} from './type-overrides';
import type { Introspection, LatestIntrospection, SupportedIntrospection, Table } from './types';
import type { Logger } from '@forestadmin/datasource-toolkit';
import type { Dialect, Sequelize } from 'sequelize';

import { IntrospectionFormatError } from '@forestadmin/datasource-toolkit';

import introspectionDialectFactory from './dialects/dialect-factory';
import DefaultValueParser from './helpers/default-value-parser';
import SqlTypeConverter from './helpers/sql-type-converter';

export default class Introspector {
  static readonly FORMAT_VERSION = 3;
  static readonly SOURCE = '@forestadmin/datasource-sql';

  static async migrateOrIntrospect(
    sequelize: Sequelize,
    logger?: Logger,
    introspection?: SupportedIntrospection,
  ): Promise<LatestIntrospection> {
    const latestIntrospection = this.getIntrospectionInLatestFormat(introspection);

    if (latestIntrospection) return latestIntrospection;

    return this.introspect(sequelize, logger);
  }

  static async introspect(sequelize: Sequelize, logger?: Logger): Promise<LatestIntrospection> {
    const dialect = introspectionDialectFactory(sequelize.getDialect() as Dialect);
    const tableNames = await this.getTableNames(dialect, sequelize as SequelizeWithOptions);
    const tables = await this.getTables(dialect, tableNames, sequelize, logger);
    const views = await this.getViews(dialect, sequelize as SequelizeWithOptions, logger);

    this.sanitizeInPlace(tables, logger);

    return { tables, views, version: this.FORMAT_VERSION, source: this.SOURCE };
  }

  static getIntrospectionInLatestFormat(
    introspection?: SupportedIntrospection,
  ): LatestIntrospection | undefined {
    if (!introspection) return undefined;
    const version = this.getProperty<number>(introspection, 'version');
    const source = this.getProperty<string>(introspection, 'source');

    if (version && version > this.FORMAT_VERSION) {
      /* This can only occur in CLOUD version, either:
        - forest-cloud does not have the same version of datasource-sql
          as cloud-agent-manager & forestadmin-server (We need to fix)
        - datasource-sql should be updated in the local repository
          of the client. He should be prompted to update forest-cloud.
      */
      throw new IntrospectionFormatError(this.SOURCE);
    }

    if (source && source !== this.SOURCE) {
      throw new Error(
        `This introspection has not been generated by the package @forestadmin/datasource-sql, but with ${source}.`,
      );
    }

    return this.migrateIntrospectionInLatestFormat(introspection);
  }

  private static migrateIntrospectionInLatestFormat(
    introspection?: SupportedIntrospection,
  ): LatestIntrospection | undefined {
    if (!introspection) return undefined;

    // First version of introspection: just an array of tables
    if (Array.isArray(introspection)) {
      return {
        tables: introspection,
        views: [],
        version: this.FORMAT_VERSION,
        source: this.SOURCE,
      };
    }

    return {
      ...(introspection as Introspection),
      views: this.getProperty(introspection, 'views') || [],
      source: this.SOURCE,
      version: this.FORMAT_VERSION,
    } as LatestIntrospection;
  }

  /** Get names of all tables in the public schema of the db */
  private static async getTableNames(
    dialect: IntrospectionDialect,
    sequelize: SequelizeWithOptions,
  ): Promise<SequelizeTableIdentifier[]> {
    const tableIdentifiers: ({ tableName: string } | string)[] = await sequelize
      .getQueryInterface()
      .showAllTables();

    const requestedSchema = sequelize.options.schema || dialect.getDefaultSchema(sequelize);

    // Sometimes sequelize returns only strings,
    // and sometimes objects with a tableName and schema property.
    // @see https://github.com/sequelize/sequelize/blob/main/src/dialects/mariadb/query.js#L295
    return (
      tableIdentifiers
        .map((tableIdentifier: string | SequelizeTableIdentifier) =>
          typeof tableIdentifier === 'string'
            ? { tableName: tableIdentifier, schema: requestedSchema }
            : {
                schema: tableIdentifier.schema || requestedSchema,
                tableName: tableIdentifier.tableName,
              },
        )
        // MSSQL returns all tables, not filtered by schema
        .filter(identifier => identifier.schema === requestedSchema)
    );
  }

  private static async getTables(
    dialect: IntrospectionDialect,
    tableNames: SequelizeTableIdentifier[],
    sequelize: Sequelize,
    logger: Logger,
  ): Promise<Table[]> {
    const tablesColumns = await dialect.listColumns(tableNames, sequelize);

    return Promise.all(
      tableNames.map((tableIdentifier, index) => {
        const columnDescriptions = tablesColumns[index];

        return this.getTable(dialect, sequelize, tableIdentifier, columnDescriptions, logger);
      }),
    );
  }

  /** Instrospect a single table */
  private static async getTable(
    dialect: IntrospectionDialect,
    sequelize: Sequelize,
    tableIdentifier: SequelizeTableIdentifier,
    columnDescriptions: ColumnDescription[],
    logger: Logger,
  ): Promise<Table> {
    const queryInterface = sequelize.getQueryInterface() as QueryInterfaceExt;
    // Sequelize is not consistent in the way it handles table identifiers either when it returns
    // it, when it uses it internally, or when it is passed as an argument.
    // Plus it has some bugs with schema handling in postgresql that forces us to be sure that
    // the table identifier is correct on our side
    const tableIdentifierForQuery = dialect.getTableIdentifier(tableIdentifier);

    const [tableIndexes, references] = await Promise.all([
      queryInterface.showIndex(tableIdentifierForQuery),
      this.getTableReferences(tableIdentifier, tableIdentifierForQuery, queryInterface, logger),
    ]);

    const columns = await Promise.all(
      columnDescriptions.map(async columnDescription => {
        const columnReferences = references.filter(r => r.columnName === columnDescription.name);

        const options = {
          name: columnDescription.name,
          description: columnDescription,
          references: columnReferences,
        };

        return this.getColumn(sequelize, logger, tableIdentifier, options);
      }),
    );

    return {
      name: tableIdentifierForQuery.tableName,
      schema: tableIdentifierForQuery.schema,
      columns: columns.filter(Boolean),
      unique: tableIndexes
        .filter(i => i.unique || i.primary)
        .map(i => i.fields.map(f => f.attribute)),
    };
  }

  private static async getTableReferences(
    tableIdentifier: SequelizeTableIdentifier,
    tableIdentifierForQuery: SequelizeTableIdentifier,
    queryInterface: QueryInterfaceExt,
    logger: Logger,
  ) {
    const tableReferences = await queryInterface.getForeignKeyReferencesForTable(
      tableIdentifierForQuery,
    );
    const processedTableReferences = tableReferences.map(tableReference => ({
      ...tableReference,
      tableName:
        typeof tableReference.tableName === 'string'
          ? tableReference.tableName
          : // On SQLite, the query interface returns an object with a tableName property
            tableReference.tableName.tableName,
      // A true composite FK has multiple rows with the same constraint but different columns.
      // We must compare columnName to avoid false positives from Sequelize's cross-schema join:
      // its FK query joins constraint_column_usage on constraint_name without schema qualifier,
      // so when two schemas have tables with the same name and FK columns with the same name,
      // PostgreSQL's identical auto-constraint names cause a cross-join that duplicates rows.
      composite:
        tableReferences.filter(
          reference =>
            reference.constraintName &&
            reference.constraintName === tableReference.constraintName &&
            reference.columnName !== tableReference.columnName,
        ).length > 0,
    }));

    const compositeRelations = processedTableReferences
      .filter(processedTableReference => processedTableReference.composite)
      .map(processedTableReference => processedTableReference.constraintName)
      .filter((constraint, index, array) => array.indexOf(constraint) === index);

    if (compositeRelations.length) {
      // sequelize does not support composite keys https://github.com/sequelize/sequelize/issues/311
      // so the agent does not either
      logger?.(
        'Warn',
        `Composite relations are not supported. skipping '${compositeRelations.join("','")}' on '${
          tableIdentifierForQuery.tableName
        }'`,
      );
    }

    const filtered = processedTableReferences.filter(
      // There is a bug right now with sequelize on postgresql: returned association
      // are not filtered on the schema. So we have to filter them manually.
      // Should be fixed with Sequelize v7
      r =>
        r.tableName === tableIdentifier.tableName &&
        r.tableSchema === tableIdentifier.schema &&
        !r.composite,
    );

    // Deduplicate: the Sequelize cross-schema join may produce duplicate rows that only
    // differ in referencedTableSchema. Keep one per (constraintName, columnName).
    return filtered.filter(
      (ref, index, arr) =>
        arr.findIndex(
          r => r.constraintName === ref.constraintName && r.columnName === ref.columnName,
        ) === index,
    );
  }

  private static async getColumn(
    sequelize: Sequelize,
    logger: Logger,
    tableIdentifier: SequelizeTableIdentifier,
    options: {
      name: string;
      description: ColumnDescription;
      references: SequelizeReference[];
    },
  ): Promise<Table['columns'][number]> {
    const { name, description, references } = options;

    try {
      const type = await SqlTypeConverter.convert(tableIdentifier, description);

      return {
        type,
        // Only use autoIncrement for PK when there's a chance of not having a Literal Default Value
        autoIncrement: description.primaryKey && description.autoIncrement,
        defaultValue:
          description.primaryKey && description.autoIncrement
            ? null
            : DefaultValueParser.parse(description, type),
        isLiteralDefaultValue: description.isLiteralDefaultValue,
        name,
        allowNull: description.allowNull,
        primaryKey: description.primaryKey,
        constraints: references.map(r => ({
          table: r.referencedTableName,
          column: r.referencedColumnName,
        })),
      };
    } catch (e) {
      logger?.('Warn', `Skipping column ${tableIdentifier.tableName}.${name} (${e.message})`);
    }
  }

  /**
   * Remove references to entities that are not present in the schema
   * (happens when we skip entities because of errors)
   */
  private static sanitizeInPlace(tables: Table[], logger?: Logger): void {
    for (const table of tables) {
      // Remove unique indexes which depend on columns that are not present in the table.
      table.unique = table.unique.filter(unique =>
        unique.every(column => table.columns.find(c => c.name === column)),
      );

      for (const column of table.columns) {
        const references = column.constraints || [];
        // Remove references to tables that are not present in the schema.
        column.constraints = references.filter(constraint => {
          const refTable = tables.find(t => t.name === constraint.table);
          const refColumn = refTable?.columns.find(c => c.name === constraint.column);

          return refTable && refColumn;
        });

        this.logBrokenRelationship(references, column.constraints, table.name, logger);
      }
    }
  }

  private static logBrokenRelationship(
    allConstraints: Table['columns'][number]['constraints'],
    sanitizedConstraints: Table['columns'][number]['constraints'],
    tableName: string,
    logger: Logger,
  ) {
    const missingConstraints = allConstraints.filter(
      constraint => !sanitizedConstraints.includes(constraint),
    );

    missingConstraints.forEach(constraint => {
      logger?.(
        'Error',
        `Failed to load constraints on relation on table '${tableName}' referencing '${constraint.table}.${constraint.column}'. The relation will be ignored.`,
      );
    });
  }

  private static async getViews(
    dialect: IntrospectionDialect,
    sequelize: SequelizeWithOptions,
    logger: Logger,
  ): Promise<Table[]> {
    const viewNames = await dialect.listViews(sequelize);
    const allColumns = await dialect.listColumns(viewNames, sequelize);

    return Promise.all(
      viewNames.map(async (viewName, index) => {
        const viewColumns = allColumns[index];

        const columns = await Promise.all(
          viewColumns.map(async columnDescription => {
            const options = {
              name: columnDescription.name,
              description: columnDescription,
              references: [],
            };

            return this.getColumn(sequelize, logger, viewName, options);
          }),
        );

        return {
          name: viewName.tableName,
          schema: viewName.schema,
          columns: columns.filter(Boolean),
          unique: [],
        };
      }),
    );
  }

  private static getProperty<T>(introspection: SupportedIntrospection, property: string): T {
    if (!Array.isArray(introspection) && property in introspection) {
      return introspection[property];
    }

    return undefined;
  }
}
